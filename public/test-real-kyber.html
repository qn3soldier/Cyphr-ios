<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîê REAL Kyber1024 Test - FIXED VERSION</title>
    <style>
        body { font-family: monospace; background: #000; color: #0f0; padding: 20px; }
        .result { margin: 10px 0; padding: 10px; border-left: 4px solid #0f0; }
        .error { border-left-color: #f00; color: #f00; }
        .success { border-left-color: #0f0; color: #0f0; }
        .info { border-left-color: #00f; color: #00f; }
        button { background: #333; color: #0f0; border: 1px solid #0f0; padding: 10px 20px; margin: 5px; cursor: pointer; }
        button:hover { background: #0f0; color: #000; }
    </style>
</head>
<body>
    <h1>üîê REAL Kyber1024 Post-Quantum Cryptography Test</h1>
    <p>Testing the FIXED pqc-kyber implementation</p>
    
    <button onclick="testRealKyber()">üöÄ TEST KYBER1024</button>
    <button onclick="clearResults()">üóëÔ∏è CLEAR</button>
    
    <div id="results"></div>

    <script type="module">
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            document.getElementById('results').appendChild(div);
            console.log(message);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        async function testRealKyber() {
            try {
                log('üîç TESTING FIXED KYBER1024 IMPLEMENTATION...', 'info');
                
                // Import with correct path
                log('1Ô∏è‚É£ Importing pqc-kyber with FIXED path...', 'info');
                const { keypair, encapsulate, decapsulate, Params } = await import('/node_modules/pqc-kyber/pqc_kyber.js');
                log('‚úÖ Successfully imported pqc-kyber functions!', 'success');
                
                // Test key generation
                log('2Ô∏è‚É£ Testing key generation...', 'info');
                const startKeyGen = performance.now();
                const keys = keypair();
                const keyGenTime = performance.now() - startKeyGen;
                
                if (!keys || !keys.pubkey || !keys.secret) {
                    throw new Error('Key generation failed - invalid keys');
                }
                
                log(`‚úÖ Key generation successful in ${keyGenTime.toFixed(2)}ms`, 'success');
                log(`   Public key: ${keys.pubkey.length} bytes`, 'info');
                log(`   Secret key: ${keys.secret.length} bytes`, 'info');
                
                // Test encapsulation
                log('3Ô∏è‚É£ Testing encapsulation...', 'info');
                const startEncaps = performance.now();
                const encaps = encapsulate(keys.pubkey);
                const encapsTime = performance.now() - startEncaps;
                
                if (!encaps || !encaps.ciphertext || !encaps.sharedSecret) {
                    throw new Error('Encapsulation failed - invalid result');
                }
                
                log(`‚úÖ Encapsulation successful in ${encapsTime.toFixed(2)}ms`, 'success');
                log(`   Ciphertext: ${encaps.ciphertext.length} bytes`, 'info');
                log(`   Shared secret: ${encaps.sharedSecret.length} bytes`, 'info');
                
                // Test decapsulation
                log('4Ô∏è‚É£ Testing decapsulation...', 'info');
                const startDecaps = performance.now();
                const decaps = decapsulate(encaps.ciphertext, keys.secret);
                const decapsTime = performance.now() - startDecaps;
                
                if (!decaps) {
                    throw new Error('Decapsulation failed - no result');
                }
                
                log(`‚úÖ Decapsulation successful in ${decapsTime.toFixed(2)}ms`, 'success');
                log(`   Decapsulated secret: ${decaps.length} bytes`, 'info');
                
                // Verify shared secrets match
                log('5Ô∏è‚É£ Verifying shared secrets...', 'info');
                const secretsMatch = encaps.sharedSecret.length === decaps.length &&
                    encaps.sharedSecret.every((byte, i) => byte === decaps[i]);
                
                if (secretsMatch) {
                    log('‚úÖ SHARED SECRETS MATCH - KYBER1024 IS WORKING!', 'success');
                } else {
                    log('‚ùå SHARED SECRETS DO NOT MATCH - CRITICAL ERROR!', 'error');
                    return;
                }
                
                // Performance check
                const totalTime = keyGenTime + encapsTime + decapsTime;
                log(`‚ö° Total time: ${totalTime.toFixed(2)}ms`, totalTime < 20 ? 'success' : 'error');
                
                if (totalTime < 20) {
                    log('‚úÖ Performance target met: < 20ms', 'success');
                } else {
                    log(`‚ö†Ô∏è Performance target missed: ${totalTime.toFixed(2)}ms > 20ms`, 'error');
                }
                
                // Check parameters
                log('6Ô∏è‚É£ Checking Kyber parameters...', 'info');
                log(`   Public key size: ${Params.publicKeyBytes} bytes`, 'info');
                log(`   Secret key size: ${Params.secretKeyBytes} bytes`, 'info');
                log(`   Ciphertext size: ${Params.ciphertextBytes} bytes`, 'info');
                log(`   Shared secret size: ${Params.sharedSecretBytes} bytes`, 'info');
                
                // Final test - multiple iterations
                log('7Ô∏è‚É£ Running stability test (10 iterations)...', 'info');
                let allPassed = true;
                let totalIterationTime = 0;
                
                for (let i = 0; i < 10; i++) {
                    const iterStart = performance.now();
                    const iterKeys = keypair();
                    const iterEncaps = encapsulate(iterKeys.pubkey);
                    const iterDecaps = decapsulate(iterEncaps.ciphertext, iterKeys.secret);
                    const iterTime = performance.now() - iterStart;
                    totalIterationTime += iterTime;
                    
                    const iterMatch = iterEncaps.sharedSecret.every((byte, idx) => byte === iterDecaps[idx]);
                    if (!iterMatch) {
                        allPassed = false;
                        log(`‚ùå Iteration ${i+1} failed`, 'error');
                        break;
                    }
                }
                
                if (allPassed) {
                    const avgTime = totalIterationTime / 10;
                    log(`‚úÖ All 10 iterations passed! Average: ${avgTime.toFixed(2)}ms`, 'success');
                    log('', 'info');
                    log('üéâüéâüéâ KYBER1024 IS FULLY WORKING AND READY FOR PRODUCTION! üéâüéâüéâ', 'success');
                    log('‚úÖ Post-quantum cryptography is now functional', 'success');
                    log('‚úÖ All performance targets met', 'success');
                    log('‚úÖ Stability test passed', 'success');
                    log('', 'info');
                    log('üöÄ READY TO PROCEED WITH FULL APPLICATION TESTING!', 'success');
                } else {
                    log('‚ùå Stability test failed', 'error');
                }
                
            } catch (error) {
                log(`‚ùå KYBER1024 TEST FAILED: ${error.message}`, 'error');
                console.error('Full error:', error);
                
                if (error.message.includes('import')) {
                    log('üîß Import error detected. Trying alternative import method...', 'info');
                    try {
                        const kyberAlt = await import('pqc-kyber');
                        log('‚úÖ Alternative import successful', 'success');
                        log(`Available methods: ${Object.keys(kyberAlt).join(', ')}`, 'info');
                    } catch (altError) {
                        log(`‚ùå Alternative import failed: ${altError.message}`, 'error');
                    }
                }
            }
        }

        // Make functions global
        window.testRealKyber = testRealKyber;
        window.clearResults = clearResults;

        // Auto-start test on page load
        document.addEventListener('DOMContentLoaded', () => {
            log('üîê FIXED Kyber1024 Test Suite Loaded', 'success');
            log('Click "TEST KYBER1024" button to verify post-quantum cryptography', 'info');
            
            // Auto-run after 1 second
            setTimeout(() => {
                log('üöÄ Auto-starting Kyber1024 test...', 'info');
                testRealKyber();
            }, 1000);
        });
    </script>
</body>
</html>