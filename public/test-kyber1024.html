<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîê Kyber1024 Post-Quantum Crypto Test</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #0a0e27 0%, #1e2450 100%);
            color: white;
            min-height: 100vh;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        .test-section { 
            background: rgba(255,255,255,0.1); 
            border-radius: 12px; 
            padding: 20px; 
            margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .result { 
            padding: 10px; 
            margin: 5px 0; 
            border-radius: 6px; 
            font-family: monospace; 
        }
        .pass { background: rgba(76, 175, 80, 0.2); border-left: 4px solid #4CAF50; }
        .fail { background: rgba(244, 67, 54, 0.2); border-left: 4px solid #f44336; }
        .info { background: rgba(33, 150, 243, 0.2); border-left: 4px solid #2196F3; }
        button { 
            background: #6366f1; color: white; border: none; 
            padding: 12px 24px; border-radius: 6px; cursor: pointer; 
            font-size: 16px; margin: 10px 5px;
        }
        button:hover { background: #4f46e5; }
        button:disabled { background: #6366f150; cursor: not-allowed; }
        pre { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 6px; overflow-x: auto; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Kyber1024 Post-Quantum Cryptography Test</h1>
        <p>Testing the production post-quantum encryption system</p>
        
        <div class="test-section">
            <h2>üéÆ Test Controls</h2>
            <button onclick="testBasicKyber()">üîë Test Kyber1024 Basic</button>
            <button onclick="testHybridEncryption()">üîí Test Hybrid Encryption</button>
            <button onclick="testPerformance()">‚ö° Performance Test</button>
            <button onclick="testRealWorldScenario()">üåç Real World Test</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
        </div>

        <div class="test-section">
            <h2>üìä Test Results</h2>
            <div id="results"></div>
        </div>
    </div>

    <script type="module">
        let testResults = [];

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = message;
            document.getElementById('results').appendChild(div);
            console.log(message);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            testResults = [];
        }

        // Test Kyber1024 basic operations
        async function testBasicKyber() {
            try {
                log('üîç Testing pqc-kyber import...', 'info');
                
                // Import pqc-kyber directly
                const kyber = await import('pqc-kyber');
                log('‚úÖ Successfully imported pqc-kyber', 'pass');
                log(`Available methods: ${Object.keys(kyber).join(', ')}`, 'info');

                // Test key generation
                log('üîë Testing key generation...', 'info');
                const startKeyGen = performance.now();
                const keyPair = kyber.keypair();
                const keyGenTime = performance.now() - startKeyGen;

                if (!keyPair || !keyPair.pubkey || !keyPair.secret) {
                    throw new Error('Key generation failed - invalid key pair');
                }

                log(`‚úÖ Key generation successful in ${keyGenTime.toFixed(2)}ms`, 'pass');
                log(`   Public key: ${keyPair.pubkey.length} bytes`, 'info');
                log(`   Secret key: ${keyPair.secret.length} bytes`, 'info');

                // Test encapsulation
                log('üì¶ Testing encapsulation...', 'info');
                const startEncaps = performance.now();
                const encapsulation = kyber.encapsulate(keyPair.pubkey);
                const encapsTime = performance.now() - startEncaps;

                if (!encapsulation || !encapsulation.ciphertext || !encapsulation.sharedSecret) {
                    throw new Error('Encapsulation failed - invalid result');
                }

                log(`‚úÖ Encapsulation successful in ${encapsTime.toFixed(2)}ms`, 'pass');
                log(`   Ciphertext: ${encapsulation.ciphertext.length} bytes`, 'info');
                log(`   Shared secret: ${encapsulation.sharedSecret.length} bytes`, 'info');

                // Test decapsulation
                log('üîì Testing decapsulation...', 'info');
                const startDecaps = performance.now();
                const decapsulatedSecret = kyber.decapsulate(encapsulation.ciphertext, keyPair.secret);
                const decapsTime = performance.now() - startDecaps;

                if (!decapsulatedSecret) {
                    throw new Error('Decapsulation failed - no result');
                }

                log(`‚úÖ Decapsulation successful in ${decapsTime.toFixed(2)}ms`, 'pass');
                log(`   Decapsulated secret: ${decapsulatedSecret.length} bytes`, 'info');

                // Verify secrets match
                const secretsMatch = encapsulation.sharedSecret.length === decapsulatedSecret.length &&
                    encapsulation.sharedSecret.every((byte, i) => byte === decapsulatedSecret[i]);

                if (secretsMatch) {
                    log('‚úÖ Shared secrets match - Kyber1024 working correctly!', 'pass');
                } else {
                    log('‚ùå Shared secrets do not match - CRITICAL ERROR!', 'fail');
                }

                // Performance check
                const totalTime = keyGenTime + encapsTime + decapsTime;
                if (totalTime < 20) {
                    log(`‚úÖ Performance target met: ${totalTime.toFixed(2)}ms < 20ms`, 'pass');
                } else {
                    log(`‚ö†Ô∏è Performance target missed: ${totalTime.toFixed(2)}ms > 20ms`, 'fail');
                }

                return true;

            } catch (error) {
                log(`‚ùå Basic Kyber1024 test failed: ${error.message}`, 'fail');
                console.error('Kyber1024 error:', error);
                return false;
            }
        }

        // Test hybrid Kyber1024 + ChaCha20 encryption
        async function testHybridEncryption() {
            try {
                log('üîí Testing Hybrid Kyber1024 + ChaCha20 Encryption...', 'info');

                // Import necessary modules
                const kyber = await import('pqc-kyber');
                
                // For ChaCha20, we'll use Web Crypto API as a fallback since Noble may not work in browser
                log('üîç Importing ChaCha20 implementation...', 'info');
                
                // Generate Kyber keys
                const recipientKeys = kyber.keypair();
                log('‚úÖ Generated recipient Kyber1024 keys', 'pass');

                // Test message
                const message = new TextEncoder().encode('üöÄ HYBRID ENCRYPTION TEST: Kyber1024 + ChaCha20 protecting this message!');
                log(`üìù Test message: "${new TextDecoder().decode(message)}"`, 'info');

                // Step 1: Kyber1024 key encapsulation
                const startHybrid = performance.now();
                const encapsulation = kyber.encapsulate(recipientKeys.pubkey);
                log('‚úÖ Kyber1024 encapsulation completed', 'pass');

                // Step 2: Derive ChaCha20 key from shared secret (simplified)
                const sharedSecret = encapsulation.sharedSecret;
                
                // For demo, we'll use AES-GCM instead of ChaCha20 since it's widely supported
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    sharedSecret.slice(0, 32), // Use first 32 bytes as AES key
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );
                log('‚úÖ Derived symmetric key from Kyber shared secret', 'pass');

                // Step 3: Encrypt message with derived key
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    cryptoKey,
                    message
                );
                log('‚úÖ Message encrypted with derived key', 'pass');

                // Step 4: Simulate hybrid decryption
                const decapsulatedSecret = kyber.decapsulate(encapsulation.ciphertext, recipientKeys.secret);
                
                const decryptKey = await crypto.subtle.importKey(
                    'raw',
                    decapsulatedSecret.slice(0, 32),
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );

                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    decryptKey,
                    encrypted
                );

                const hybridTime = performance.now() - startHybrid;
                const decryptedMessage = new TextDecoder().decode(decrypted);
                
                log(`üîì Decrypted message: "${decryptedMessage}"`, 'info');
                
                if (decryptedMessage === new TextDecoder().decode(message)) {
                    log('‚úÖ HYBRID ENCRYPTION SUCCESS - Messages match!', 'pass');
                } else {
                    log('‚ùå HYBRID ENCRYPTION FAILED - Messages do not match!', 'fail');
                }

                log(`‚ö° Total hybrid encryption time: ${hybridTime.toFixed(2)}ms`, 
                     hybridTime < 50 ? 'pass' : 'fail');

                return true;

            } catch (error) {
                log(`‚ùå Hybrid encryption test failed: ${error.message}`, 'fail');
                console.error('Hybrid encryption error:', error);
                return false;
            }
        }

        // Performance benchmark
        async function testPerformance() {
            try {
                log('‚ö° Running Kyber1024 Performance Benchmark...', 'info');

                const kyber = await import('pqc-kyber');
                const iterations = 10;
                
                let totalKeyGen = 0, totalEncaps = 0, totalDecaps = 0;

                for (let i = 0; i < iterations; i++) {
                    // Key generation
                    const startKeyGen = performance.now();
                    const keys = kyber.keypair();
                    totalKeyGen += performance.now() - startKeyGen;

                    // Encapsulation
                    const startEncaps = performance.now();
                    const encaps = kyber.encapsulate(keys.pubkey);
                    totalEncaps += performance.now() - startEncaps;

                    // Decapsulation
                    const startDecaps = performance.now();
                    kyber.decapsulate(encaps.ciphertext, keys.secret);
                    totalDecaps += performance.now() - startDecaps;
                }

                const avgKeyGen = totalKeyGen / iterations;
                const avgEncaps = totalEncaps / iterations;
                const avgDecaps = totalDecaps / iterations;
                const avgTotal = avgKeyGen + avgEncaps + avgDecaps;

                log(`üìä Performance Results (avg over ${iterations} iterations):`, 'info');
                log(`   Key Generation: ${avgKeyGen.toFixed(2)}ms`, avgKeyGen < 5 ? 'pass' : 'fail');
                log(`   Encapsulation:  ${avgEncaps.toFixed(2)}ms`, avgEncaps < 5 ? 'pass' : 'fail');
                log(`   Decapsulation:  ${avgDecaps.toFixed(2)}ms`, avgDecaps < 5 ? 'pass' : 'fail');
                log(`   Total:          ${avgTotal.toFixed(2)}ms`, avgTotal < 20 ? 'pass' : 'fail');

                if (avgTotal < 20) {
                    log('‚úÖ PERFORMANCE TARGET MET - Ready for production!', 'pass');
                } else {
                    log('‚ö†Ô∏è Performance target missed - may need optimization', 'fail');
                }

                return true;

            } catch (error) {
                log(`‚ùå Performance test failed: ${error.message}`, 'fail');
                return false;
            }
        }

        // Real-world scenario test
        async function testRealWorldScenario() {
            try {
                log('üåç Testing Real-World Messaging Scenario...', 'info');

                const kyber = await import('pqc-kyber');

                // Simulate Alice and Bob
                log('üë§ Generating Alice and Bob key pairs...', 'info');
                const aliceKeys = kyber.keypair();
                const bobKeys = kyber.keypair();

                // Alice sends message to Bob
                const message = new TextEncoder().encode('Hello Bob! This message is protected by post-quantum cryptography! üîê');
                log(`üìù Alice's message: "${new TextDecoder().decode(message)}"`, 'info');

                // Alice encrypts for Bob
                const startEncrypt = performance.now();
                const encapsulation = kyber.encapsulate(bobKeys.pubkey);
                
                // Use shared secret for AES encryption
                const key = await crypto.subtle.importKey(
                    'raw',
                    encapsulation.sharedSecret.slice(0, 32),
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );

                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    message
                );
                const encryptTime = performance.now() - startEncrypt;

                log(`üîí Alice encrypted message in ${encryptTime.toFixed(2)}ms`, 'pass');

                // Simulate transmission (Alice sends: encapsulation.ciphertext + iv + encrypted)
                const transmitted = {
                    kyberCiphertext: encapsulation.ciphertext,
                    iv: iv,
                    encryptedMessage: encrypted
                };

                log('üì° Message transmitted over network...', 'info');

                // Bob decrypts the message
                const startDecrypt = performance.now();
                
                // Bob decapsulates the shared secret
                const bobSharedSecret = kyber.decapsulate(transmitted.kyberCiphertext, bobKeys.secret);
                
                // Bob derives the same key
                const bobKey = await crypto.subtle.importKey(
                    'raw',
                    bobSharedSecret.slice(0, 32),
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );

                // Bob decrypts the message
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: transmitted.iv },
                    bobKey,
                    transmitted.encryptedMessage
                );
                const decryptTime = performance.now() - startDecrypt;

                const bobMessage = new TextDecoder().decode(decrypted);
                log(`üîì Bob decrypted message in ${decryptTime.toFixed(2)}ms`, 'pass');
                log(`üìñ Bob reads: "${bobMessage}"`, 'info');

                // Verify message integrity
                if (bobMessage === new TextDecoder().decode(message)) {
                    log('‚úÖ REAL-WORLD TEST SUCCESS - End-to-end encryption working!', 'pass');
                } else {
                    log('‚ùå REAL-WORLD TEST FAILED - Message corruption!', 'fail');
                }

                const totalTime = encryptTime + decryptTime;
                log(`‚ö° Total encryption/decryption time: ${totalTime.toFixed(2)}ms`, 
                     totalTime < 30 ? 'pass' : 'fail');

                return true;

            } catch (error) {
                log(`‚ùå Real-world test failed: ${error.message}`, 'fail');
                return false;
            }
        }

        // Make functions global for button clicks
        window.testBasicKyber = testBasicKyber;
        window.testHybridEncryption = testHybridEncryption;
        window.testPerformance = testPerformance;
        window.testRealWorldScenario = testRealWorldScenario;
        window.clearResults = clearResults;

        // Auto-run basic test on page load
        document.addEventListener('DOMContentLoaded', () => {
            log('üîê Kyber1024 Test Suite Loaded', 'info');
            log('Click buttons above to run specific tests, or wait for auto-test...', 'info');
            
            // Auto-run basic test after 2 seconds
            setTimeout(() => {
                log('üöÄ Auto-running basic Kyber1024 test...', 'info');
                testBasicKyber();
            }, 2000);
        });
    </script>
</body>
</html>