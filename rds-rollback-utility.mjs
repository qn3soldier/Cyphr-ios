#!/usr/bin/env node

/**
 * üîÑ CYPHR MESSENGER - RDS ROLLBACK UTILITY
 * 
 * Emergency rollback and cleanup utility for RDS migration
 * Use this if migration fails and you need to clean up
 */

import fs from 'fs/promises';
import path from 'path';
import pg from 'pg';
import { fileURLToPath } from 'url';
import readline from 'readline';

const { Pool } = pg;
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// RDS Configuration (same as migration script)
const RDS_CONFIG = {
    host: 'cyphr-messenger-db.c123abc456def.us-east-1.rds.amazonaws.com', // Replace with actual
    port: 5432,
    database: 'cyphr_messenger',
    user: 'postgres',
    password: 'Cyphr2025EnterpriseSecurePassword123',
    ssl: {
        rejectUnauthorized: true,
        ca: await fs.readFile(path.join(__dirname, 'global-bundle.pem'), 'utf8')
    }
};

function createInterface() {
    return readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
}

async function askQuestion(question) {
    const rl = createInterface();
    return new Promise((resolve) => {
        rl.question(question, (answer) => {
            rl.close();
            resolve(answer);
        });
    });
}

async function backupCurrentData() {
    console.log('üíæ BACKING UP CURRENT RDS DATA...');
    
    const pool = new Pool(RDS_CONFIG);
    
    try {
        const client = await pool.connect();
        
        // Get list of tables
        const tablesResult = await client.query(`
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            ORDER BY table_name
        `);
        
        const tables = tablesResult.rows.map(row => row.table_name);
        
        if (tables.length === 0) {
            console.log('‚ÑπÔ∏è  No tables found to backup');
            client.release();
            return null;
        }
        
        // Create backup directory
        const backupDir = path.join(__dirname, 'rds-backup', new Date().toISOString().split('T')[0]);
        await fs.mkdir(backupDir, { recursive: true });
        
        const backup = {
            timestamp: new Date().toISOString(),
            tables: {},
            totalRows: 0
        };
        
        for (const table of tables) {
            try {
                const result = await client.query(`SELECT * FROM ${table}`);
                backup.tables[table] = {
                    rowCount: result.rows.length,
                    data: result.rows
                };
                backup.totalRows += result.rows.length;
                console.log(`üíæ ${table}: ${result.rows.length} rows backed up`);
            } catch (error) {
                console.warn(`‚ö†Ô∏è  Failed to backup ${table}:`, error.message);
            }
        }
        
        // Save backup
        const backupFile = path.join(backupDir, 'rds-backup.json');
        await fs.writeFile(backupFile, JSON.stringify(backup, null, 2));
        
        console.log(`‚úÖ Backup saved to: ${backupFile}`);
        console.log(`üìä Total rows backed up: ${backup.totalRows}`);
        
        client.release();
        return backupFile;
        
    } catch (error) {
        console.error('‚ùå Backup failed:', error.message);
        return null;
    } finally {
        await pool.end();
    }
}

async function dropAllTables() {
    console.log('üóëÔ∏è  DROPPING ALL TABLES...');
    
    const pool = new Pool(RDS_CONFIG);
    
    try {
        const client = await pool.connect();
        
        // Get all tables
        const tablesResult = await client.query(`
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            ORDER BY table_name
        `);
        
        const tables = tablesResult.rows.map(row => row.table_name);
        
        if (tables.length === 0) {
            console.log('‚ÑπÔ∏è  No tables to drop');
            client.release();
            return;
        }
        
        await client.query('BEGIN');
        
        // Drop tables in reverse order to handle dependencies
        for (const table of tables.reverse()) {
            try {
                await client.query(`DROP TABLE IF EXISTS ${table} CASCADE`);
                console.log(`üóëÔ∏è  Dropped ${table}`);
            } catch (error) {
                console.warn(`‚ö†Ô∏è  Failed to drop ${table}:`, error.message);
            }
        }
        
        await client.query('COMMIT');
        console.log('‚úÖ All tables dropped successfully');
        
        client.release();
        
    } catch (error) {
        console.error('‚ùå Drop tables failed:', error.message);
        throw error;
    } finally {
        await pool.end();
    }
}

async function cleanupDatabase() {
    console.log('üßπ CLEANING UP DATABASE...');
    
    const pool = new Pool(RDS_CONFIG);
    
    try {
        const client = await pool.connect();
        
        // Clean up sequences
        const sequencesResult = await client.query(`
            SELECT sequence_name 
            FROM information_schema.sequences 
            WHERE sequence_schema = 'public'
        `);
        
        for (const row of sequencesResult.rows) {
            await client.query(`DROP SEQUENCE IF EXISTS ${row.sequence_name} CASCADE`);
            console.log(`üî¢ Dropped sequence: ${row.sequence_name}`);
        }
        
        // Clean up functions
        const functionsResult = await client.query(`
            SELECT routine_name 
            FROM information_schema.routines 
            WHERE routine_schema = 'public' 
            AND routine_type = 'FUNCTION'
        `);
        
        for (const row of functionsResult.rows) {
            await client.query(`DROP FUNCTION IF EXISTS ${row.routine_name}() CASCADE`);
            console.log(`üîß Dropped function: ${row.routine_name}`);
        }
        
        console.log('‚úÖ Database cleaned up');
        client.release();
        
    } catch (error) {
        console.error('‚ùå Cleanup failed:', error.message);
    } finally {
        await pool.end();
    }
}

async function showCurrentState() {
    console.log('üìä CURRENT DATABASE STATE');
    console.log('=========================');
    
    const pool = new Pool(RDS_CONFIG);
    
    try {
        const client = await pool.connect();
        
        // Show connection info
        const versionResult = await client.query('SELECT version()');
        console.log(`üêò PostgreSQL: ${versionResult.rows[0].version.split(' ')[0]}`);
        
        const sslResult = await client.query('SELECT ssl_is_used()');
        console.log(`üîí SSL: ${sslResult.rows[0].ssl_is_used ? '‚úÖ' : '‚ùå'}`);
        
        // Show tables
        const tablesResult = await client.query(`
            SELECT table_name, 
                   (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = t.table_name) as columns
            FROM information_schema.tables t 
            WHERE table_schema = 'public' 
            ORDER BY table_name
        `);
        
        if (tablesResult.rows.length === 0) {
            console.log('üìã Tables: None (empty database)');
        } else {
            console.log('üìã Tables:');
            let totalRows = 0;
            
            for (const row of tablesResult.rows) {
                try {
                    const countResult = await client.query(`SELECT COUNT(*) as count FROM ${row.table_name}`);
                    const rowCount = parseInt(countResult.rows[0].count);
                    totalRows += rowCount;
                    console.log(`  ‚Ä¢ ${row.table_name}: ${rowCount} rows, ${row.columns} columns`);
                } catch (error) {
                    console.log(`  ‚Ä¢ ${row.table_name}: Error reading rows`);
                }
            }
            
            console.log(`üìà Total rows: ${totalRows}`);
        }
        
        client.release();
        
    } catch (error) {
        console.error('‚ùå Failed to show state:', error.message);
    } finally {
        await pool.end();
    }
}

async function runRollback() {
    console.log('üîÑ CYPHR MESSENGER - RDS ROLLBACK UTILITY');
    console.log('==========================================');
    
    try {
        // Show current state
        await showCurrentState();
        
        console.log('\nüö® ROLLBACK OPTIONS:');
        console.log('1. üíæ Backup current data (recommended before any changes)');
        console.log('2. üóëÔ∏è  Drop all tables (clean slate)');
        console.log('3. üßπ Full cleanup (tables + sequences + functions)');
        console.log('4. üìä Show current state only');
        console.log('5. ‚ùå Exit');
        
        const choice = await askQuestion('\nüî¢ Enter your choice (1-5): ');
        
        switch (choice) {
            case '1':
                const backupFile = await backupCurrentData();
                if (backupFile) {
                    console.log('\n‚úÖ Backup completed successfully');
                    console.log(`üìÅ Backup location: ${backupFile}`);
                } else {
                    console.log('\n‚ùå Backup failed');
                }
                break;
                
            case '2':
                const confirmDrop = await askQuestion('\n‚ö†Ô∏è  Are you sure you want to DROP ALL TABLES? This cannot be undone! (yes/no): ');
                if (confirmDrop.toLowerCase() === 'yes') {
                    await dropAllTables();
                    console.log('\n‚úÖ All tables dropped');
                } else {
                    console.log('‚ùå Operation cancelled');
                }
                break;
                
            case '3':
                const confirmClean = await askQuestion('\n‚ö†Ô∏è  Are you sure you want to COMPLETELY CLEAN the database? This cannot be undone! (yes/no): ');
                if (confirmClean.toLowerCase() === 'yes') {
                    await dropAllTables();
                    await cleanupDatabase();
                    console.log('\n‚úÖ Database completely cleaned');
                } else {
                    console.log('‚ùå Operation cancelled');
                }
                break;
                
            case '4':
                // Already showed state above
                break;
                
            case '5':
                console.log('üëã Goodbye!');
                return;
                
            default:
                console.log('‚ùå Invalid choice');
                return;
        }
        
        // Show final state
        console.log('\nüìä FINAL STATE AFTER OPERATION:');
        await showCurrentState();
        
    } catch (error) {
        console.error('\nüí• Rollback utility failed:', error);
    }
}

// Execute rollback utility
if (import.meta.url === `file://${__filename}`) {
    runRollback()
        .then(() => {
            console.log('\nüèÅ Rollback utility completed');
            process.exit(0);
        })
        .catch(error => {
            console.error('üí• Rollback utility failed:', error);
            process.exit(1);
        });
}

export { runRollback };